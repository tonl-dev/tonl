/**
 * BF004: Prototype Pollution - Exploit Tests
 *
 * These tests MUST FAIL before the fix is applied.
 * After the fix, they should pass (attacks blocked).
 */

import { describe, it, beforeEach, afterEach } from 'node:test';
import assert from 'node:assert';
import { TONLDocument } from '../../../dist/document.js';
import { SecurityError } from '../../../dist/errors/index.js';

describe('BF004: Prototype Pollution - Exploit Tests', () => {
  // Clean up any pollution before each test
  beforeEach(() => {
    // Remove any polluted properties
    delete (Object.prototype as any).polluted;
    delete (Object.prototype as any).isAdmin;
    delete (Object.prototype as any).hacked;
    delete (Array.prototype as any).polluted;
  });

  afterEach(() => {
    // Clean up after each test
    delete (Object.prototype as any).polluted;
    delete (Object.prototype as any).isAdmin;
    delete (Object.prototype as any).hacked;
    delete (Array.prototype as any).polluted;
  });

  describe('__proto__ Access in Queries', () => {
    it('should block or reject __proto__ property access', () => {
      const doc = TONLDocument.fromJSON({
        user: { name: 'Alice', '__proto__': 'should not work' }
      });

      // Parser might reject this with syntax error or SecurityError
      // Either way, it should not succeed
      assert.throws(
        () => doc.query('user.__proto__'),
        Error, // Accept any error (SecurityError or parse error)
        'Should not allow __proto__ access'
      );
    });

    it('should block __proto__ in deeply nested paths', () => {
      const doc = TONLDocument.fromJSON({
        a: { b: { c: { '__proto__': 'bad' } } }
      });

      assert.throws(
        () => doc.query('a.b.c.__proto__'),
        Error,
        'Should block nested __proto__'
      );
    });

    it('should not access __proto__ via property chain', () => {
      const doc = TONLDocument.fromJSON({
        data: { normal: 'value' }
      });

      // Even if __proto__ somehow gets through parser, evaluator should block it
      // This tests the evaluator-level protection
      const result = doc.get('data.normal');
      assert.strictEqual(result, 'value');

      // Attempting to access __proto__ properties should fail or return undefined
      try {
        const protoAccess = doc.get('data.__proto__');
        // If it doesn't throw, it should at least return undefined
        assert.strictEqual(protoAccess, undefined, '__proto__ should not be accessible');
      } catch (error) {
        // Throwing is also acceptable
        assert.ok(true, '__proto__ blocked with error');
      }
    });
  });

  describe('constructor Access', () => {
    it('should block or reject constructor property access', () => {
      const doc = TONLDocument.fromJSON({
        user: { name: 'Alice', 'constructor': 'fake' }
      });

      // Should block constructor access (parser or evaluator)
      assert.throws(
        () => doc.query('user.constructor'),
        Error,
        'Should not allow constructor access'
      );
    });

    it('should block constructor.prototype access', () => {
      const doc = TONLDocument.fromJSON({
        user: { name: 'Alice' }
      });

      assert.throws(
        () => doc.query('user.constructor.prototype'),
        Error,
        'Should block constructor.prototype'
      );
    });
  });

  describe('prototype Access', () => {
    it('should block or reject prototype property access', () => {
      const doc = TONLDocument.fromJSON({
        user: { name: 'Alice', 'prototype': 'fake' }
      });

      assert.throws(
        () => doc.query('user.prototype'),
        Error,
        'Should not allow prototype access'
      );
    });
  });

  describe('Prototype Pollution via Set', () => {
    it('should block __proto__ in set operations', () => {
      const doc = TONLDocument.fromJSON({
        user: {}
      });

      // Should throw error (SecurityError or parse error)
      assert.throws(
        () => doc.set('user.__proto__.polluted', 'yes'),
        Error,
        'Should block __proto__ set'
      );

      // Verify no pollution occurred
      const testObj = {};
      assert.strictEqual(
        (testObj as any).polluted,
        undefined,
        'Prototype should not be polluted'
      );
    });

    it('should block nested __proto__ pollution', () => {
      const doc = TONLDocument.fromJSON({
        nested: { deep: {} }
      });

      assert.throws(
        () => doc.set('nested.deep.__proto__.polluted', 'yes'),
        Error,
        'Should block nested __proto__ set'
      );

      const testObj = {};
      assert.strictEqual((testObj as any).polluted, undefined);
    });

    it('should block constructor pollution', () => {
      const doc = TONLDocument.fromJSON({
        user: {}
      });

      assert.throws(
        () => doc.set('user.constructor.polluted', 'yes'),
        Error,
        'Should block constructor'
      );

      const testObj = {};
      assert.strictEqual((testObj as any).polluted, undefined);
    });

    it('should block prototype pollution', () => {
      const doc = TONLDocument.fromJSON({
        user: {}
      });

      assert.throws(
        () => doc.set('user.prototype.polluted', 'yes'),
        Error,
        'Should block prototype'
      );

      const testObj = {};
      assert.strictEqual((testObj as any).polluted, undefined);
    });
  });

  describe('Inherited Property Protection', () => {
    it('should only access own properties (hasOwnProperty check)', () => {
      const doc = TONLDocument.fromJSON({
        user: {
          name: 'Alice',
          age: 30,
          email: 'alice@example.com'
        }
      });

      // Should return own properties
      assert.strictEqual(doc.get('user.name'), 'Alice');
      assert.strictEqual(doc.get('user.age'), 30);
      assert.strictEqual(doc.get('user.email'), 'alice@example.com');

      // Should return undefined for non-existent own property
      assert.strictEqual(doc.get('user.nonExistent'), undefined);
      assert.strictEqual(doc.get('user.notThere'), undefined);
    });

    it('hasOwnProperty check prevents inherited property access', () => {
      // Create doc with normal properties
      const doc = TONLDocument.fromJSON({
        config: {
          setting1: 'value1',
          setting2: 'value2'
        }
      });

      // Normal access works
      assert.strictEqual(doc.get('config.setting1'), 'value1');

      // Non-existent properties return undefined (not inherited values)
      assert.strictEqual(doc.get('config.missing'), undefined);

      // The hasOwnProperty check ensures we only get own properties
      // This protects against both pollution and inheriting built-in methods
      assert.ok(true, 'hasOwnProperty protection is active');
    });
  });

  describe('Other Dangerous Properties', () => {
    it('should block __defineGetter__', () => {
      const doc = TONLDocument.fromJSON({ user: { '__defineGetter__': 'fake' } });

      assert.throws(
        () => doc.query('user.__defineGetter__'),
        Error,
        'Should block __defineGetter__'
      );
    });

    it('should block __defineSetter__', () => {
      const doc = TONLDocument.fromJSON({ user: { '__defineSetter__': 'fake' } });

      assert.throws(
        () => doc.query('user.__defineSetter__'),
        Error,
        'Should block __defineSetter__'
      );
    });

    it('should block __lookupGetter__', () => {
      const doc = TONLDocument.fromJSON({ user: { '__lookupGetter__': 'fake' } });

      assert.throws(
        () => doc.query('user.__lookupGetter__'),
        Error,
        'Should block __lookupGetter__'
      );
    });

    it('should block __lookupSetter__', () => {
      const doc = TONLDocument.fromJSON({ user: { '__lookupSetter__': 'fake' } });

      assert.throws(
        () => doc.query('user.__lookupSetter__'),
        Error,
        'Should block __lookupSetter__'
      );
    });
  });

  describe('Legitimate Properties with Similar Names', () => {
    it('should allow properties containing "proto" in name', () => {
      const doc = TONLDocument.fromJSON({
        data: {
          my_proto: 'value1',
          proto_field: 'value2',
          protocol: 'https',
        }
      });

      // These are legitimate properties, not __proto__
      assert.strictEqual(doc.get('data.my_proto'), 'value1');
      assert.strictEqual(doc.get('data.proto_field'), 'value2');
      assert.strictEqual(doc.get('data.protocol'), 'https');
    });

    it('should allow properties containing "constructor" in name', () => {
      const doc = TONLDocument.fromJSON({
        data: {
          my_constructor: 'value1',
          constructor_id: '123',
          building_constructor: 'John',
        }
      });

      assert.strictEqual(doc.get('data.my_constructor'), 'value1');
      assert.strictEqual(doc.get('data.constructor_id'), '123');
      assert.strictEqual(doc.get('data.building_constructor'), 'John');
    });

    it('should allow setting properties with similar names', () => {
      const doc = TONLDocument.fromJSON({
        data: {}
      });

      // Should work - these are not dangerous
      assert.doesNotThrow(() => {
        doc.set('data.my_proto', 'value');
        doc.set('data.protocol', 'http');
        doc.set('data.constructor_id', '456');
      });

      assert.strictEqual(doc.get('data.my_proto'), 'value');
      assert.strictEqual(doc.get('data.protocol'), 'http');
      assert.strictEqual(doc.get('data.constructor_id'), '456');
    });
  });

  describe('Regression - Normal Object Operations', () => {
    it('should still access normal properties', () => {
      const doc = TONLDocument.fromJSON({
        user: {
          name: 'Alice',
          age: 30,
          email: 'alice@example.com',
        }
      });

      assert.strictEqual(doc.get('user.name'), 'Alice');
      assert.strictEqual(doc.get('user.age'), 30);
      assert.strictEqual(doc.get('user.email'), 'alice@example.com');
    });

    it('should still set normal properties', () => {
      const doc = TONLDocument.fromJSON({
        user: { name: 'Alice' }
      });

      doc.set('user.age', 30);
      doc.set('user.email', 'alice@example.com');

      assert.strictEqual(doc.get('user.age'), 30);
      assert.strictEqual(doc.get('user.email'), 'alice@example.com');
    });

    it('should return undefined for non-existent properties', () => {
      const doc = TONLDocument.fromJSON({
        user: { name: 'Alice' }
      });

      assert.strictEqual(doc.get('user.nonexistent'), undefined);
      assert.strictEqual(doc.get('user.missing.property'), undefined);
    });
  });
});
