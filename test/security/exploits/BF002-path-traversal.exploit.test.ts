/**
 * BF002: Path Traversal - Exploit Tests
 *
 * These tests MUST FAIL before the fix is applied.
 * After the fix, they should pass (attacks blocked).
 *
 * NOTE: These are unit tests for PathValidator. Integration tests with CLI
 * would be slower and harder to maintain. The validator is the critical component.
 */

import { describe, it } from 'node:test';
import assert from 'node:assert';
import { PathValidator } from '../../../dist/cli/path-validator.js';
import { SecurityError } from '../../../dist/errors/index.js';

describe('BF002: Path Traversal - Exploit Tests', () => {
  describe('Absolute Path Attacks', () => {
    it('should reject absolute Unix paths', () => {
      const maliciousPaths = [
        '/etc/passwd',
        '/root/.ssh/id_rsa',
        '/var/www/html/config.php',
        '/home/user/.env',
      ];

      for (const path of maliciousPaths) {
        assert.throws(
          () => PathValidator.validate(path),
          SecurityError,
          `Should reject absolute path: ${path}`
        );
      }
    });

    it('should reject absolute Windows paths', () => {
      const maliciousPaths = [
        'C:\\Windows\\System32\\config\\SAM',
        'C:\\Users\\Administrator\\.ssh\\id_rsa',
        'D:\\secrets\\database.pwd',
      ];

      for (const path of maliciousPaths) {
        assert.throws(
          () => PathValidator.validate(path),
          SecurityError,
          `Should reject Windows absolute path: ${path}`
        );
      }
    });
  });

  describe('Directory Traversal Attacks', () => {
    it('should reject parent directory traversal (../)', () => {
      const maliciousPaths = [
        '../etc/passwd',
        '../../etc/passwd',
        '../../../etc/passwd',
        './../../../etc/passwd',
        'innocent/../../../etc/passwd',
      ];

      for (const path of maliciousPaths) {
        assert.throws(
          () => PathValidator.validate(path),
          SecurityError,
          `Should reject traversal path: ${path}`
        );
      }
    });

    it('should reject traversal that escapes allowed directory', () => {
      // Even if normalized path looks ok, final path must be within allowed dir
      assert.throws(
        () => PathValidator.validate('subdir/../../etc/passwd'),
        SecurityError,
        'Should detect traversal even through subdirectories'
      );
    });
  });

  describe('Null Byte Injection', () => {
    it('should reject null bytes in paths', () => {
      const maliciousPaths = [
        'file\0.json',
        'test\0/etc/passwd',
      ];

      for (const path of maliciousPaths) {
        assert.throws(
          () => PathValidator.validate(path),
          SecurityError,
          `Should reject null byte: ${path}`
        );
      }
    });
  });

  describe('Windows-Specific Attacks', () => {
    it('should reject Windows UNC paths', () => {
      const maliciousPaths = [
        '\\\\server\\share\\file.json',
        '\\\\192.168.1.1\\c$\\Windows',
      ];

      for (const path of maliciousPaths) {
        if (process.platform === 'win32') {
          assert.throws(
            () => PathValidator.validate(path),
            SecurityError,
            `Should reject UNC path: ${path}`
          );
        }
      }
    });

    it('should reject Windows reserved device names', () => {
      const reservedNames = [
        'CON', 'PRN', 'AUX', 'NUL',
        'COM1', 'COM2', 'COM3',
        'LPT1', 'LPT2',
      ];

      for (const name of reservedNames) {
        if (process.platform === 'win32') {
          assert.throws(
            () => PathValidator.validate(name),
            SecurityError,
            `Should reject reserved name: ${name}`
          );
        }
      }
    });
  });

  describe('Legitimate Paths', () => {
    it('should allow relative paths in current directory', () => {
      const legitimatePaths = [
        'data.json',
        'file.txt',
        'document.tonl',
      ];

      for (const path of legitimatePaths) {
        assert.doesNotThrow(
          () => PathValidator.validate(path),
          `Should allow: ${path}`
        );
      }
    });

    it('should allow paths in subdirectories', () => {
      const legitimatePaths = [
        'subdir/file.json',
        './subdir/file.json',
        'deeply/nested/path/to/file.json',
      ];

      for (const path of legitimatePaths) {
        assert.doesNotThrow(
          () => PathValidator.validate(path),
          `Should allow: ${path}`
        );
      }
    });

    it('should normalize safe paths correctly', () => {
      // These should be normalized but still allowed
      const testCases = [
        { input: './file.json', shouldContain: 'file.json' },
        { input: 'subdir/../file.json', shouldContain: 'file.json' },
        { input: 'subdir/./file.json', shouldContain: 'file.json' },
      ];

      for (const { input, shouldContain } of testCases) {
        const result = PathValidator.validate(input);
        assert.ok(
          result.includes(shouldContain),
          `${input} should normalize to contain ${shouldContain}, got: ${result}`
        );
      }
    });
  });

  describe('Edge Cases', () => {
    it('should reject empty string', () => {
      assert.throws(
        () => PathValidator.validate(''),
        SecurityError,
        'Should reject empty string'
      );
    });

    it('should reject whitespace-only string', () => {
      assert.throws(
        () => PathValidator.validate('   '),
        SecurityError,
        'Should reject whitespace-only'
      );
    });

    it('should reject non-string paths', () => {
      assert.throws(
        () => PathValidator.validate(null as any),
        SecurityError,
        'Should reject null'
      );

      assert.throws(
        () => PathValidator.validate(undefined as any),
        SecurityError,
        'Should reject undefined'
      );

      assert.throws(
        () => PathValidator.validate(123 as any),
        SecurityError,
        'Should reject number'
      );
    });

    it('should trim and validate paths', () => {
      // Should trim whitespace and still validate
      assert.doesNotThrow(
        () => PathValidator.validate('  file.json  '),
        'Should handle leading/trailing whitespace'
      );
    });
  });

  describe('Helper Methods', () => {
    it('validateRead should require file existence', () => {
      // Non-existent file
      assert.throws(
        () => PathValidator.validateRead('nonexistent.json'),
        SecurityError,
        'Should reject non-existent file for read'
      );
    });

    it('validateWrite should not require existence', () => {
      // Non-existent file should be allowed for write
      assert.doesNotThrow(
        () => PathValidator.validateWrite('new-file.json'),
        'Should allow non-existent file for write'
      );
    });
  });
});
