var TONL=function(e){"use strict";var t=Object.defineProperty,n=(e,n,r)=>((e,n,r)=>n in e?t(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r)(e,"symbol"!=typeof n?n+"":n,r);function r(e){return null==e?"null":"boolean"==typeof e?"bool":"number"==typeof e?isFinite(e)&&Number.isInteger(e)?e>=0&&e<=4294967295?"u32":e>=-2147483648&&e<=2147483647?"i32":"f64":"f64":"string"==typeof e?"str":Array.isArray(e)?"list":"object"==typeof e?"obj":"str"}function i(e,t){const n=e.startsWith('"')?e.slice(1,-1).replace(/""/g,'"'):e;if("null"===n)return null;switch(t){case"null":return null;case"bool":return"true"===n;case"u32":if(!/^[0-9]+$/.test(n)){if(/^0[xX]/.test(n))throw new TypeError(`Invalid u32: hexadecimal notation not supported, use decimal instead: ${n}`);if(/^0[oO]/.test(n))throw new TypeError(`Invalid u32: octal notation not supported, use decimal instead: ${n}`);if(/^0[bB]/.test(n))throw new TypeError(`Invalid u32: binary notation not supported, use decimal instead: ${n}`);if(/[eE]/.test(n))throw new TypeError(`Invalid u32: scientific notation not supported for integers: ${n}`);throw new TypeError(`Invalid u32: must be decimal integer only, got: ${n}`)}const t=parseInt(n,10);if(!Number.isFinite(t)||t<0||t>4294967295)throw new RangeError(`Invalid u32: out of range (0-4294967295): ${t}`);if(t.toString()!==n)throw new RangeError(`Invalid u32: overflow detected: ${n}`);return t;case"i32":if(!/^-?[0-9]+$/.test(n)){if(/^0[xX]/.test(n))throw new TypeError(`Invalid i32: hexadecimal notation not supported, use decimal instead: ${n}`);if(/^0[oO]/.test(n))throw new TypeError(`Invalid i32: octal notation not supported, use decimal instead: ${n}`);if(/^0[bB]/.test(n))throw new TypeError(`Invalid i32: binary notation not supported, use decimal instead: ${n}`);if(/[eE]/.test(n))throw new TypeError(`Invalid i32: scientific notation not supported for integers: ${n}`);throw new TypeError(`Invalid i32: must be decimal integer only, got: ${n}`)}const r=parseInt(n,10);if(!Number.isFinite(r)||r<-2147483648||r>2147483647)throw new RangeError(`Invalid i32: out of range (-2147483648 to 2147483647): ${r}`);if(r.toString()!==n)throw new RangeError(`Invalid i32: overflow detected: ${n}`);return r;case"f64":const i=parseFloat(n);if(!Number.isFinite(i))throw new RangeError(`Invalid f64: NaN or Infinity not allowed: ${e}`);if(/\d*[eE][+-]?\d+/.test(n)&&!Number.isSafeInteger(i)&&0!==i){const e=Math.abs(i);if(e>Number.MAX_SAFE_INTEGER||e<1&&e<Number.EPSILON)throw new RangeError(`Invalid f64: scientific notation precision loss detected: ${n}`)}return i;default:return n}}function s(e){if(0===e.length)return!0;if(!e.every(e=>"object"==typeof e&&null!==e&&!Array.isArray(e)))return!1;const t=Object.keys(e[0]).sort();return e.every(e=>{const n=Object.keys(e).sort();return n.length===t.length&&n.every((e,n)=>e===t[n])})}function o(e){return 0===e.length?[]:Object.keys(e[0]).sort()}function c(e,t=.7){if(0===e.length)return!0;if(!e.every(e=>"object"==typeof e&&null!==e&&!Array.isArray(e)))return!1;const n=new Set;for(const s of e)Object.keys(s).forEach(e=>n.add(e));const r=Array.from(n),i=new Map;for(const s of r){let t=0;for(const n of e)s in n&&t++;i.set(s,t)}return Array.from(i.values()).filter(n=>n>=e.length*t).length>=r.length*t}function l(e){if(0===e.length)return[];const t=new Set;for(const n of e)n&&"object"==typeof n&&!Array.isArray(n)&&Object.keys(n).forEach(e=>t.add(e));return Array.from(t).sort()}function a(e){if(e.startsWith('"')&&e.endsWith('"')){const t=e.slice(1,-1);let n="",r=0;for(;r<t.length;)if("\\"===t[r]&&r+1<t.length){const e=t[r+1];"\\"===e||'"'===e||"r"===e||"n"===e||"t"===e?(n+="r"===e?"\r":"n"===e?"\n":"t"===e?"\t":e,r+=2):(n+=t[r],r++)}else n+=t[r],r++;return n}return e}function u(e,t){if(e.includes("\n")||e.includes('"""')){return`"""${e.replace(/\\/g,"\\\\").replace(/\r/g,"\\r").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/"""/g,'\\"""')}"""`}return function(e,t){return function(e,t){return""===e||"true"===e||"false"===e||"null"===e||"undefined"===e||"Infinity"===e||"-Infinity"===e||"NaN"===e||!!/^-?\d+$/.test(e)||!!/^-?\d*\.\d+$/.test(e)||!!/^-?\d+\.?\d*e[+-]?\d+$/i.test(e)||e.includes(t)||e.includes(":")||e.includes("{")||e.includes("}")||e.includes("#")||e.includes('"')||e.includes("\n")||e.includes("\t")||e.includes("\r")||e.startsWith(" ")||e.endsWith(" ")}(e,t)?`"${e.replace(/\\/g,"\\\\").replace(/\r/g,"\\r").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/"/g,'\\"')}"`:e}(e,t)}function h(e,t){if(!Number.isSafeInteger(e)||e<0)throw new RangeError(`Invalid indent level: ${e} (must be non-negative safe integer)`);if(!Number.isSafeInteger(t)||t<0||t>100)throw new RangeError(`Invalid spaces value: ${t} (must be 0-100)`);const n=e*t;if(n>1e4)throw new RangeError(`Total indent too large: ${n} spaces (max: 10000). This may indicate excessive nesting depth or a DoS attack.`);return" ".repeat(n)}function p(e,t={}){const n=t.delimiter||",",r=t.includeTypes??!1,i=t.version||"1.0",s={delimiter:n,includeTypes:r,version:i,indent:void 0!==t.indent&&Number.isFinite(t.indent)&&t.indent>=0?t.indent:2,singleLinePrimitiveLists:t.singleLinePrimitiveLists??!0,prettyDelimiters:t.prettyDelimiters??!1,compactTables:t.compactTables??!1,schemaFirst:t.schemaFirst??!1,currentIndent:0,seen:new WeakSet,currentDepth:0,maxDepth:500},o=[];o.push(`#version ${i}`),","!==n&&o.push(`#delimiter ${"\t"===n?"\\t":n}`);const c=f(e,"root",s);return c&&o.push(c),o.join("\n")}function f(e,t,n){if(null===e)return`${t}: null`;if(void 0===e)return"";if(Array.isArray(e))return m(e,t,n);if("object"==typeof e)return function(e,t,n){const i=n.currentDepth??0,s=n.maxDepth??500;if(i>=s)throw new Error(`Maximum nesting depth exceeded (${s}) at key: ${t}. This may indicate deeply nested data or a circular reference.`);if(n.compactTables&&function(e){const t=Object.keys(e);if(t.length<=1)return!1;const n=t.some(t=>{const n=e[t];return null!=n&&!Array.isArray(n)&&"object"!=typeof n}),r=t.some(t=>Array.isArray(e[t]));return n&&r}(e))return function(e,t,n){const r=Object.keys(e).sort(),i=[];i.push(`${t}:`);const s={...n,currentIndent:n.currentIndent+1,currentDepth:(n.currentDepth??0)+1};for(const o of r){const t=e[o];if(void 0===t)continue;const r=h(s.currentIndent,s.indent);if(Array.isArray(t)){const e=d(t,o,s);i.push(r+e)}else if("object"==typeof t&&null!==t){const e=f(t,o,s);i.push(r+e)}else{let e;if(null===t)e="null";else if(!0===t||!1===t)e=String(t);else if("number"==typeof t)e=String(t);else{const r=String(t);e=r.includes(n.delimiter)||r.includes("\n")||r.includes(":")||r.includes('"')?u(r,n.delimiter):r}i.push(`${r}${o}: ${e}`)}}return i.join("\n")}(e,t,n);n.seen||(n.seen=new WeakSet);if(n.seen.has(e))throw new Error(`Circular reference detected at key: ${t} (object already processed)`);try{for(const[n,r]of Object.entries(e))if(r===e)throw new Error(`Self-reference detected at key: ${t}.${n}`)}catch(y){if(!(y instanceof TypeError))throw y}n.seen.add(e);const o=Reflect.ownKeys(e).filter(e=>"string"==typeof e).filter(t=>void 0!==e[t]).sort(),c=[],l=o.some(t=>{const n=e[t];return"object"==typeof n&&null!==n&&!Array.isArray(n)}),a=o.some(e=>e.includes(":")||e.includes(",")||e.includes("{")||e.includes("}")||e.includes('"')||e.includes("#")||e.includes("@")||""===e);for(const u of o){const t=e[u];let i=u;if((u.includes(":")||u.includes(",")||u.includes("{")||u.includes("}")||u.includes('"')||u.includes("#")||u.includes("@")||""===u.trim()||u.startsWith(" ")||u.endsWith(" ")||u.includes("\t")||u.includes("\n")||u.includes("\r"))&&(i=`"${u.replace(/\\/g,"\\\\").replace(/\r/g,"\\r").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/"/g,'\\"')}"`),n.includeTypes){const e=r(t);"obj"!==e&&"list"!==e&&(i+=`:${e}`)}c.push(i)}let p;p=1===o.length?`${t}:`:`${t}{${c.join(",")}}:`;const m=Object.values(e).some(e=>"string"==typeof e&&(e.includes("\n")||e.includes(n.delimiter)||e.includes(":"))),g=1===o.length;if(l||Object.values(e).some(e=>Array.isArray(e))||m||a||g||o.length>1){const t=[p],r={...n,currentIndent:n.currentIndent+1,currentDepth:(n.currentDepth??0)+1};for(const i of o){const s=e[i],o=i.includes(":")||i.includes(",")||i.includes("{")||i.includes("}")||i.includes('"')||i.includes("#")||i.includes("@")||""===i.trim()||i.startsWith(" ")||i.endsWith(" ")||i.includes("\t")||i.includes("\n")||i.includes("\r")?`"${i.replace(/\\/g,"\\\\").replace(/\r/g,"\\r").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/"/g,'\\"')}"`:i;if(Array.isArray(s)||"object"==typeof s&&null!==s){const e=f(s,i,r);t.push(h(r.currentIndent,r.indent)+e)}else if(null===s)t.push(h(r.currentIndent,r.indent)+`${o}: null`);else if(!0===s||!1===s)t.push(h(r.currentIndent,r.indent)+`${o}: ${String(s)}`);else if("number"==typeof s)t.push(h(r.currentIndent,r.indent)+`${o}: ${String(s)}`);else if(void 0!==s){const e=u(String(s),n.delimiter);t.push(h(r.currentIndent,r.indent)+`${o}: ${e}`)}}return t.join("\n")}{const t=[p];for(const r of o){const i=e[r],s=r.includes(":")||r.includes(",")||r.includes("{")||r.includes("}")||r.includes('"')||r.includes("#")||r.includes("@")||""===r.trim()||r.startsWith(" ")||r.endsWith(" ")||r.includes("\t")||r.includes("\n")||r.includes("\r")?`"${r.replace(/\\/g,"\\\\").replace(/\r/g,"\\r").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/"/g,'\\"')}"`:r;if(null===i)t.push(`${s}: null`);else if(!0===i||!1===i)t.push(`${s}: ${String(i)}`);else if("number"==typeof i)t.push(`${s}: ${String(i)}`);else if(void 0!==i){const e=u(String(i),n.delimiter);t.push(`${s}: ${e}`)}}return t.join(" ")}}(e,t,n);if(!0===e||!1===e||null===e)return`${t}: ${String(e)}`;if("number"==typeof e)return Number.isFinite(e)?`${t}: ${String(e)}`:`${t}: null`;return`${t}: ${u(String(e),n.delimiter)}`}function d(e,t,n){if(0===e.length)return`${t}[0]:`;const i=s(e),a=!i&&c(e,.6),p=e[0];if((i||a)&&p&&"object"==typeof p&&!Array.isArray(p)){if(e.every(e=>e&&Object.values(e).every(e=>null==e||"object"!=typeof e&&"function"!=typeof e))){const i=a?l(e):o(e),s=[];for(const t of i){let i=t;if((t.includes(":")||t.includes(",")||t.includes("{")||t.includes("}")||t.includes('"'))&&(i=`"${t.replace(/"/g,'\\"')}"`),n.includeTypes){let n=null;for(const r of e){const e=r;if(e&&"object"==typeof e&&!Array.isArray(e)&&t in e&&null!==e[t]&&void 0!==e[t]){n=e[t];break}}const s=r(n);"obj"!==s&&"list"!==s&&(i+=`:${s}`)}s.push(i)}const c=[`${t}[${e.length}]{${s.join(",")}}:`],p={...n,currentIndent:n.currentIndent+1};for(const t of e){if(!t||"object"!=typeof t||Array.isArray(t))continue;const e=[];for(const s of i){const r=t[s];if(s in t&&void 0!==r)if(null===r)e.push("null");else if(!0===r||!1===r)e.push(String(r));else if("number"==typeof r)e.push(String(r));else{const t=String(r);t.includes(n.delimiter)||t.includes("\n")||t.includes(":")||t.includes('"')?e.push(u(t,n.delimiter)):e.push(t)}else e.push("")}const r=n.prettyDelimiters?` ${n.delimiter} `:n.delimiter;c.push(h(p.currentIndent,p.indent)+e.join(r))}return c.join("\n")}}return m(e,t,n)}function m(e,t,n){const i=n.currentDepth??0,a=n.maxDepth??500;if(i>=a)throw new Error(`Maximum nesting depth exceeded (${a}) at key: ${t}. This may indicate deeply nested data or a circular reference.`);if(n.schemaFirst&&function(e){if(0===e.length)return!1;const t=e[0];return!(!t||"object"!=typeof t||Array.isArray(t))&&(!!s(e)&&e.every(e=>!!e&&Object.values(e).every(e=>null==e||"object"!=typeof e&&"function"!=typeof e||!!Array.isArray(e)&&e.every(e=>null==e||"object"!=typeof e&&"function"!=typeof e))))}(e)){const i=function(e,t,n){if(0===e.length)return`${t}[0]:`;if(e.length>3)return null;const i=e[0],s=o(e),c=[];for(const o of s){let e=o;const t=i[o];if(Array.isArray(t))e+="[]";else if(n.includeTypes){const n=r(t);"obj"!==n&&"list"!==n&&(e+=`:${n}`)}c.push(e)}const l=[`#schema ${t}{${c.join(",")}}`],a={...n,currentIndent:n.currentIndent+1,currentDepth:(n.currentDepth??0)+1};for(const r of e){if(!r||"object"!=typeof r||Array.isArray(r))continue;const e=[];for(const i of s){const t=r[i];if(i in r&&void 0!==t)if(null===t)e.push("null");else if(!0===t||!1===t)e.push(String(t));else if("number"==typeof t)e.push(String(t));else if(Array.isArray(t))if(0===t.length)e.push("[]");else if(t.some(e=>"string"==typeof e&&e.includes(n.delimiter))){const n=t.map(e=>"string"==typeof e?e:JSON.stringify(e)).join("|");e.push(`[${n}]`)}else{const r=t.map(e=>"string"==typeof e?e:JSON.stringify(e));e.push(`[${r.join(n.delimiter)}]`)}else{const r=String(t);r.includes(n.delimiter)||r.includes("\n")||r.includes(":")||r.includes('"')?e.push(u(r,n.delimiter)):e.push(r)}else e.push("")}const t=n.prettyDelimiters?` ${n.delimiter} `:n.delimiter;l.push(h(a.currentIndent,a.indent)+e.join(t))}return l.join("\n")}(e,t,n);if(null!==i)return i}if(n.seen||(n.seen=new WeakSet),n.seen.has(e))throw new Error(`Circular reference detected at key: ${t} (array already processed)`);if(e.includes(e))throw new Error(`Self-reference detected at key: ${t} (array contains itself)`);if(n.seen.add(e),0===e.length)return`${t}[0]:`;const p=s(e),d=!p&&c(e,.6),m=e[0];if((p||d)&&m&&"object"==typeof m&&!Array.isArray(m)){if(e.every(e=>e&&Object.values(e).every(e=>null==e||"object"!=typeof e&&"function"!=typeof e))){const i=d?l(e):o(e),s=[];for(const t of i){let i=t;if((t.includes(":")||t.includes(",")||t.includes("{")||t.includes("}")||t.includes('"'))&&(i=`"${t.replace(/"/g,'\\"')}"`),n.includeTypes){let n=null;for(const r of e){const e=r;if(e&&"object"==typeof e&&!Array.isArray(e)&&t in e&&null!==e[t]&&void 0!==e[t]){n=e[t];break}}const s=r(n);"obj"!==s&&"list"!==s&&(i+=`:${s}`)}s.push(i)}const c=[`${t}[${e.length}]{${s.join(",")}}:`],a={...n,currentIndent:n.currentIndent+1,currentDepth:(n.currentDepth??0)+1};for(const t of e){if(!t||"object"!=typeof t||Array.isArray(t))continue;const e=[];for(const s of i){const r=t[s];if(s in t&&void 0!==r)if(null===r)e.push("null");else if(!0===r||!1===r)e.push(String(r));else if("number"==typeof r)e.push(String(r));else{const t=u(String(r),n.delimiter);e.push(t)}else e.push("")}const r=n.prettyDelimiters?` ${n.delimiter} `:n.delimiter;c.push(h(a.currentIndent,a.indent)+e.join(r))}return c.join("\n")}{const r=[`${t}[${e.length}]:`],i={...n,currentIndent:n.currentIndent+1,currentDepth:(n.currentDepth??0)+1};for(let t=0;t<e.length;t++){const s=e[t];if("object"==typeof s&&null!==s){const e=f(s,`[${t}]`,i);r.push(h(i.currentIndent,i.indent)+e)}else if(null===s)r.push(h(i.currentIndent,i.indent)+`[${t}]: null`);else if(!0===s||!1===s)r.push(h(i.currentIndent,i.indent)+`[${t}]: ${String(s)}`);else if("number"==typeof s)r.push(h(i.currentIndent,i.indent)+`[${t}]: ${String(s)}`);else if(void 0!==s){const e=u(String(s),n.delimiter);r.push(h(i.currentIndent,i.indent)+`[${t}]: ${e}`)}}return r.join("\n")}}if(e.every(e=>"object"!=typeof e||null===e)){const r=e.map(e=>null==e?"null":!0===e||!1===e?String(e):"number"==typeof e?Number.isFinite(e)?String(e):"null":u(String(e),n.delimiter)),i=n.prettyDelimiters?` ${n.delimiter} `:n.delimiter;return`${t}[${e.length}]: ${r.join(i)}`}{const r=[`${t}[${e.length}]:`],i={...n,currentIndent:n.currentIndent+1,currentDepth:(n.currentDepth??0)+1};for(let t=0;t<e.length;t++){const s=e[t];if(Array.isArray(s)){if(s.every(e=>null==e||"object"!=typeof e&&"function"!=typeof e)){const e=s.map(e=>null==e?"null":!0===e||!1===e?String(e):"number"==typeof e?Number.isFinite(e)?String(e):"null":u(String(e),n.delimiter)),o=n.prettyDelimiters?` ${n.delimiter} `:n.delimiter;r.push(h(i.currentIndent,i.indent)+`[${t}][${s.length}]: ${e.join(o)}`)}else{const e=f(s,`[${t}]`,i);r.push(h(i.currentIndent,i.indent)+e)}}else if("object"==typeof s&&null!==s){const e=f(s,`[${t}]`,i);r.push(h(i.currentIndent,i.indent)+e)}else if(null===s)r.push(h(i.currentIndent,i.indent)+`[${t}]: null`);else if(void 0!==s){let e;e="number"==typeof s||"boolean"==typeof s?String(s):u(String(s),n.delimiter),r.push(h(i.currentIndent,i.indent)+`[${t}]: ${e}`)}}return r.join("\n")}}class g extends Error{constructor(e,t,n,r){super(e),this.line=t,this.column=n,this.source=r,this.name="TONLError",Error.captureStackTrace(this,this.constructor)}toString(){let e=`${this.name}: ${this.message}`;const t="production"!==process.env.NODE_ENV;return void 0!==this.line&&(t?(e+=`\n  at line ${this.line}`,void 0!==this.column&&(e+=`:${this.column}`)):e+=` (line ${this.line})`),this.source&&t&&(e+=`\n\n  ${this.source}`,void 0!==this.column&&(e+=`\n  ${" ".repeat(this.column)}^`)),e}}class y extends g{constructor(e,t,n,r,i){super(e,t,n,r),this.suggestion=i,this.name="TONLParseError"}toString(){let e=super.toString();return this.suggestion&&(e+=`\n\nðŸ’¡ Suggestion: ${this.suggestion}`),e}}const E=1e5;function b(e,t=","){if(!e||""===e.trim())return[];if(e.length>E)throw new y(`Line exceeds maximum length: ${e.length} characters (max: 100000)`);const n={mode:"plain",currentField:"",fields:[],i:0,currentFieldWasQuoted:!1};let r=0;for(;n.i<e.length;){const i=e[n.i],s=e[n.i+1];switch(n.mode){case"plain":'"'===i?'"'===s&&'"'===e[n.i+2]?(n.mode="inTripleQuote",n.currentFieldWasQuoted=!0,n.currentField='"""',n.i+=2):(n.mode="inQuote",n.currentFieldWasQuoted=!0):"\\"===i&&void 0!==s&&s===t?(n.currentField+=t,n.i++):i===t?0===r?(n.currentFieldWasQuoted?n.fields.push(n.currentField):n.fields.push(n.currentField.trim()),n.currentField="",n.currentFieldWasQuoted=!1):n.currentField+=i:(" "!==i&&"\t"!==i||0!==n.currentField.length||'"'!==s)&&(" "!==i&&"\t"!==i||0!==n.currentField.length?"["===i?(r++,n.currentField+=i):"]"===i?(r>0&&r--,n.currentField+=i):n.currentField+=i:n.currentField+=i);break;case"inQuote":"\\"===i&&void 0!==s?'"'===s?(n.currentField+='"',n.i++):"\\"===s?(n.currentField+="\\",n.i++):"r"===s?(n.currentField+="\r",n.i++):"n"===s?(n.currentField+="\n",n.i++):"t"===s?(n.currentField+="\t",n.i++):n.currentField+=i:'"'===i?'"'===s?(n.currentField+='"',n.i++):n.mode="plain":"["===i?(r++,n.currentField+=i):"]"===i?(r>0&&r--,n.currentField+=i):n.currentField+=i;break;case"inTripleQuote":'"'===i&&'"'===s&&'"'===e[n.i+2]?(n.currentField+='"""',n.mode="plain",n.i+=2):"["===i?(r++,n.currentField+=i):"]"===i?(r>0&&r--,n.currentField+=i):n.currentField+=i}n.i++}if(n.currentFieldWasQuoted?n.fields.push(n.currentField):n.fields.push(n.currentField.trim()),n.fields.length>1e4)throw new y(`Too many fields: ${n.fields.length} (max: 10000)`);return n.fields}function A(e){const t=e.trim();if(!t.startsWith("#"))return null;const n=t.match(/^#(\w+)\s+(.+)$/);return n?{key:n[1],value:n[2].trim()}:null}function $(e){const t=e.trim();if(!t.endsWith(":"))return null;const n=t.slice(0,-1);let r,i;const s=n.match(/^\[(\d+)\]/);if(s)r=`[${s[1]}]`,i=n.slice(s[0].length);else{const e=n.match(/^([a-zA-Z_][a-zA-Z0-9_]*)/);if(!e)return null;r=e[1],i=n.slice(r.length)}let o,c=!1,l=i;const a=i.match(/^\[(\d+)\]/);a&&(c=!0,o=parseInt(a[1],10),l=i.slice(a[0].length));const u=[],h=l.match(/^\{(.+)\}$/);if(h){const e=function(e){const t=[];let n="",r=!1;for(let i=0;i<e.length;i++){const s=e[i];'"'===s?i+1<e.length&&'"'===e[i+1]?(n+='""',i++):(r=!r,n+='"'):","!==s||r?n+=s:(t.push(n),n="")}n&&t.push(n);return t}(h[1]);for(const t of e){const e=t.trim();if(!e)continue;let n,r;if(e.startsWith('"')){const t=e.indexOf('"',1);if(t>0){n=e.slice(1,t).replace(/""/g,'"');const i=e.slice(t+1),s=i.indexOf(":");s>=0&&(r=i.slice(s+1).trim())}else n=e}else{const t=e.indexOf(":");t>0?(n=e.slice(0,t).trim(),r=e.slice(t+1).trim()):n=e}r?u.push({name:n,type:r}):u.push({name:n})}}return{key:r,isArray:c,arrayLength:o,columns:u}}function v(e){const t=e.match(/^#delimiter\s+([,|\t;])/m);if(t){const e=t[1];if(","===e||"|"===e||"\t"===e||";"===e)return e}const n=e.split("\n");for(const r of n){const e=r.trim();if(e&&!e.startsWith("#")&&!e.endsWith("{")&&!e.endsWith(":")){let t=0,n=0,r=0,i=0;for(let o=0;o<e.length;o++)switch(e[o]){case",":t++;break;case"|":n++;break;case"\t":r++;break;case";":i++}const s=Math.max(t,n,r,i);if(0===s)return",";if(t===s)return",";if(n===s)return"|";if(r===s)return"\t";if(i===s)return";"}}return","}function T(e,t){const n=/^\s*$/.test(e)?e:e.trim();if("null"===n)return null;if("undefined"!==n){if("true"===n)return!0;if("false"===n)return!1;if("Infinity"===n)return 1/0;if("-Infinity"===n)return-1/0;if("NaN"===n)return NaN;if(n.startsWith('"""')&&n.endsWith('"""'))return n.slice(3,-3).replace(/\\"""/g,'"""').replace(/\\\\/g,"\\").replace(/\\r/g,"\r").replace(/\\n/g,"\n").replace(/\\t/g,"\t");if(n.startsWith('"')&&n.endsWith('"'))return a(n);if(/^-?\d+$/.test(n)){const e=parseInt(n,10);return Number.isFinite(e)?Math.abs(e)>Number.MAX_SAFE_INTEGER?n:e:n}if(/^-?\d*\.\d+$/.test(n)){const e=parseFloat(n);return Number.isFinite(e)?e:n}if(/^-?\d+\.?\d*e[+-]?\d+$/i.test(n)){const e=parseFloat(n);return Number.isFinite(e)?e:n}return n}}function I(e,t,n){if(!e)throw new Error("Header cannot be null in parseSingleLineObject");if(e.isArray){const r=b(t,n.delimiter);if(0===e.columns.length)throw new Error("Array header must define at least one column when using tabular format");const i=void 0!==e.arrayLength?e.arrayLength:Math.floor(r.length/e.columns.length),s=[];for(let t=0;t<i;t++){const n={};for(let i=0;i<e.columns.length;i++){const s=t*e.columns.length+i;if(s<r.length){const t=e.columns[i],o=r[s];n[t.name]=T(o)}}s.push(n)}return s}{const e={};let n=0;const r=t.length;for(;n<r;){const i=t.substring(n).match(/^([^:]+):\s*/);if(!i)break;const s=i[1].trim();n+=i[0].length;let o=r;const c=t.substring(n).match(/\s+[a-zA-Z0-9_]+\s*:/);c&&void 0!==c.index&&(o=n+c.index);const l=t.substring(n,o).trim();e[s]=T(l),n=o}return e}}function w(e,t){const n=[],r=e[t];if(!r)return n;const i=r.match(/^(\s*)/)?.[1]?.length||0;let s=t+1;for(;s<e.length;){const t=e[s];if(!t.trim()){n.push(t),s++;continue}if((t.match(/^(\s*)/)?.[1]?.length||0)<=i)break;n.push(t),s++}return n}function S(e,t,n){const r=e[t],i=r?.match(/^(\s*)/)?.[1]?.length||0;let s=t+1;for(;s<e.length;){const t=e[s],n=t.trim();if(!n){s++;continue}if((t.match(/^(\s*)/)?.[1]?.length||0)<=i&&(n.endsWith(":")||n.startsWith("#")))return s;s++}return s}function O(e,t=","){if(!e||""===e.trim())return[];const n=[];let r="",i=0,s=!1,o=!1;for(let c=0;c<e.length;c++){const l=e[c];o?(r+=l,o=!1):"\\"===l&&s?(o=!0,r+=l):'"'!==l||s?'"'===l&&s?(s=!1,r+=l):"["!==l||s?"]"!==l||s?l!==t||0!==i||s?r+=l:(n.push(r.trim()),r=""):(i--,r+=l):(i++,r+=l):(s=!0,r+=l)}return r.trim()&&n.push(r.trim()),n}function N(e,t,n,r){if(!e)throw new Error("Invalid header for block parsing");const s=r.currentDepth||0,o=r.maxDepth||500;if(s>=o)throw new y(`Maximum nesting depth exceeded (${o}). Possible deeply nested structure or circular reference.`,r.currentLine,void 0,t[n]);const c=[],l=t[n]?.match(/^(\s*)/)?.[1]?.length||0;let a=n+1,u=!1;for(;a<t.length;){const n=t[a],r=n.trim();if(!r){a++;continue}const i=n.match(/^(\s*)/)?.[1]?.length||0;let s=!1;if(r.includes('"""')){const e=[];let t=0,n=r.indexOf('"""',t);for(;-1!==n;)e.push(n),t=n+3,n=r.indexOf('"""',t);if(u)(r.endsWith('"""')&&1===e.length||r.endsWith('"""')&&e.length>1)&&(u=!1,s=!0);else if(e.length>=2)s=!0;else if(1===e.length){r.substring(e[0]+3).length>0||!r.endsWith('"""')?u=!0:s=!0}}if(!u&&i<l)break;if(!u&&!s&&i===l){const t=r.endsWith(":");if(!e.isArray||t)break}c.push(n),a++}return e.isArray?function(e,t,n){const r=[];if(e&&0!==e.columns.length)for(const s of t){const t=s.trim();if(!t||t.startsWith("#"))continue;if(t.startsWith("@")){const e=t.indexOf(":");if(e>0){const n=t.substring(1,e).trim();if(["version","delimiter","import","schema","type","description"].includes(n))continue}}const o=b(t,n.delimiter);if(0===o.length)continue;if(o.length>e.columns.length){if(n.strict)throw new Error(`Too many values for array with ${e.columns.length} columns: got ${o.length} values`);o.length=e.columns.length}const c={};for(let n=0;n<e.columns.length&&n<o.length;n++){const t=e.columns[n],r=o[n];if(""!==r)if(r.startsWith("[")||r.includes("{"))c[t.name]=T(r);else{let e;e=t.type?i(r,t.type):T(r),c[t.name]=e}}r.push(c)}else{const e=t.some(e=>null!==$(e.trim())),i=t.some(e=>{const t=e.trim();return/^\[\d+\]/.test(t)});if(e||i)for(let s=0;s<t.length;s++){const e=t[s],o=e.trim();if(o&&!o.startsWith("#")){if(o.startsWith("@")){const e=o.indexOf(":");if(e>0){const t=o.substring(1,e).trim();if(["version","delimiter","import","schema","type","description"].includes(t))continue}}if(i){const i=o.match(/^\[(\d+)\](?:\[(\d+)\])?:\s*(.*)$/);if(i){const e=parseInt(i[1],10),o=i[2]?parseInt(i[2],10):void 0,c=i[3].trim();if(void 0!==o)if(c){const t=b(c,n.delimiter),i=[];for(const e of t)i.push(T(e));r[e]=i}else{const i=w(t,s);if(i.length>0){const t=[];for(let e=0;e<i.length;e++){const r=i[e].trim();if(!r||r.startsWith("#"))continue;const s=r.match(/^\[(\d+)\](?:\[(\d+)\])?:\s*(.*)$/);if(s){const e=parseInt(s[1],10),r=s[2]?parseInt(s[2],10):void 0,i=s[3].trim();if(void 0!==r)if(i){const r=b(i,n.delimiter),s=[];for(const e of r)s.push(T(e));t[e]=s}else t[e]=[];else t[e]=i?T(i):[]}}r[e]=t,s+=i.length}else r[e]=[]}else if(c){const t=c.startsWith('"')&&c.endsWith('"');if(!c.includes(n.delimiter)||t||c.startsWith('"""')||c.includes('"""')||c.includes(":"))r[e]=T(c);else{const t=b(c,n.delimiter),i=[];for(const e of t)i.push(T(e));r[e]=i}}else{const i=w(t,s);if(i.length>0)if(void 0!==o){if(i[0].trim().match(/^\[(\d+)\](?:\[(\d+)\])?:\s*(.*)$/)){const t=[];for(let e=0;e<i.length;e++){const r=i[e].trim();if(!r||r.startsWith("#"))continue;const s=r.match(/^\[(\d+)\](?:\[(\d+)\])?:\s*(.*)$/);if(s){const r=parseInt(s[1],10),o=s[2]?parseInt(s[2],10):void 0,c=s[3].trim();if(void 0!==o)if(c){const e=b(c,n.delimiter),i=[];for(const t of e)i.push(T(t));t[r]=i}else{const s=[];let o=e+1;for(;o<i.length;){const e=i[o];if(!(e.length>0)||" "!==e[0]&&"\t"!==e[0])break;s.push(e),o++}if(s.length>0){const i=[];for(let e=0;e<s.length;e++){const t=s[e].trim();if(!t||t.startsWith("#"))continue;const r=t.match(/^\[(\d+)\](?:\[(\d+)\])?:\s*(.*)$/);if(r){const e=parseInt(r[1],10),t=r[2]?parseInt(r[2],10):void 0,s=r[3].trim();if(void 0!==t)if(s){const t=b(s,n.delimiter),r=[];for(const e of t)r.push(T(e));i[e]=r}else i[e]=[];else i[e]=s?T(s):[]}}t[r]=i,e=o-1}else t[r]=[]}else t[r]=c?T(c):[]}}r[e]=t,s+=i.length}else{const t=R({},i,n);r[e]=t,s+=i.length}}else{const t=i[0].trim().match(/^\[(\d+)\](?:\[(\d+)\])?:\s*(.*)$/);if(t&&t[2]){const t=[];for(let e=0;e<i.length;e++){const r=i[e].trim();if(!r||r.startsWith("#"))continue;const s=r.match(/^\[(\d+)\](?:\[(\d+)\])?:\s*(.*)$/);if(s){const e=parseInt(s[1],10),r=s[2]?parseInt(s[2],10):void 0,i=s[3].trim();if(void 0!==r)if(i){const r=b(i,n.delimiter),s=[];for(const e of r)s.push(T(e));t[e]=s}else t[e]=[];else t[e]=i?T(i):[]}}r[e]=t,s+=i.length}else{const t=R({},i,n);r[e]=t,s+=i.length}}else r[e]=[]}}else{const i=$(o);if(i){const o=w(t,s),c=[e,...o],l=n.currentDepth||0,a=N(i,c,0,{...n,currentDepth:l+1}),u=i.key.match(/^\[(\d+)\]$/);if(u){r[parseInt(u[1],10)]=a}else r.push(a);s+=o.length}}}else{const i=$(o);if(i){const o=w(t,s),c=[e,...o],l=n.currentDepth||0,a=N(i,c,0,{...n,currentDepth:l+1}),u=i.key.match(/^\[(\d+)\]$/);if(u){r[parseInt(u[1],10)]=a}else r.push(a);s+=o.length}}}}else if(t.length>0){const e=t[0].trim().match(/^(.+)\[([^\]]+)\]:\s*(.+)$/);if(e){e[1].trim();const t=b(e[3].trim(),n.delimiter);for(const e of t)r.push(T(e))}else{const e=b(t[0],n.delimiter);for(const t of e)r.push(T(t))}}}if(n.strict&&e&&void 0!==e.arrayLength&&r.length!==e.arrayLength)throw new Error(`Array length mismatch: expected ${e.arrayLength}, got ${r.length}`);return r}(e,c,r):R(e,c,r)}function R(e,t,n){const r=[];for(const i of t){const e=i.trim();if(!e||e.startsWith("#")){if(e.startsWith("#schema ")){const t=e.match(/^#schema\s+(\w+)\{([^}]*)\}$/);t&&r.push("schema_first_"+t[1])}continue}if(e.startsWith("@")){const t=e.indexOf(":");if(t>0){const n=e.substring(1,t).trim();if(["version","delimiter","import","schema","type","description"].includes(n))continue}}const t=e.indexOf(":");if(t>0){let n=e.substring(0,t).trim();n.startsWith('"')&&n.endsWith('"')&&(n=n.slice(1,-1)),"__proto__"!==n&&"constructor"!==n&&"prototype"!==n||r.push(n)}}const s=r.length>0?Object.create(null):{};let o=0;for(;o<t.length;){const e=t[o],r=e.trim();if(r.startsWith("#schema ")){const e=r.match(/^#schema\s+(\w+)\{([^}]*)\}$/);if(e){const r=e[1],l=e[2],a=[];if(l){const e=l.split(",");for(const t of e){const e=t.trim();if(!e)continue;let n,r;const i=e.indexOf(":");i>0?(n=e.slice(0,i).trim(),r=e.slice(i+1).trim()):n=e,n.endsWith("[]")&&(n=n.slice(0,-2),r||(r="array")),r?a.push({name:n,type:r}):a.push({name:n})}}const u=[];for(o++;o<t.length;){const e=t[o],r=e.trim();if(!e.startsWith(" ")&&!e.startsWith("\t")&&""!==r)break;if(r){const e=O(r,n.delimiter),t={};for(let r=0;r<a.length;r++){const s=a[r],o=e[r];if(void 0!==o&&""!==o)if(o&&o.startsWith('"""')&&o.endsWith('"""'))try{const e=o.slice(3,-3);t[s.name]=JSON.parse(e)}catch(c){t[s.name]=o}else if(o&&o.startsWith("[")&&o.endsWith("]"))try{const e=o.slice(1,-1).trim();if(""===e)t[s.name]=[];else if(e.startsWith("{")||e.startsWith("["))try{t[s.name]=JSON.parse(o)}catch(c){throw c}else{let r=n.delimiter;e.includes("|")&&(r="|");const i=e.split(r).map(e=>{e=e.trim();try{return JSON.parse(e)}catch{return e}});t[s.name]=i}}catch(c){t[s.name]=o}else if(o&&(o.startsWith("[")||o.includes("[")))try{t[s.name]=JSON.parse(o)}catch(c){const e=","===n.delimiter?";":n.delimiter;if(o&&o.includes(e)){let n=o.trim();(n.startsWith('"')&&n.endsWith('"')||n.startsWith("'")&&n.endsWith("'"))&&(n=n.slice(1,-1));const r=n.split(e).map(e=>T(e=e.trim()));t[s.name]=r}else s.type?t[s.name]=i(o,s.type):t[s.name]=T(o)}else s.type?t[s.name]=i(o,s.type):t[s.name]=T(o)}u.push(t)}o++}s[r]=u;continue}}if(!r||r.startsWith("#")){o++;continue}if(r.startsWith("@")){const e=r.indexOf(":");if(e>0){const t=r.substring(1,e).trim();if(["version","delimiter","import","schema","type","description"].includes(t)){o++;continue}}}const u=r.match(/^(?:([^"\s]+)\{([^}]*)\}|("[^"]+")\{([^}]*)\}):\s+(.+)$/);if(u){const e=u[1]||u[3],t=u[2]||u[4],r=u[5].trim(),i=t.includes(","),c=r.includes(n.delimiter)&&(r.includes('"')||r.split(n.delimiter).length>1);if(i||c){const i=[];if(t){const e=t.split(",");for(const t of e){const e=t.trim();if(!e)continue;const n=e.indexOf(":");n>0?i.push({name:e.slice(0,n).trim(),type:e.slice(n+1).trim()}):i.push({name:e})}}const c={isArray:!1,columns:i};s[e]=I(c,r,n),o++;continue}}const h=$(r);if(h){const r=w(t,o),i=[e,...r],c=n.currentDepth||0,l=N(h,i,0,{...n,currentDepth:c+1});s[h.key]=l,o+=r.length+1;continue}let p=null;if(r.length<1e3)try{p=r.match(/^(.{1,200})\[([^\]]{1,20})\]:\s*(.{0,1000})$/)}catch(l){}if(p){const t=p[1].trim(),r=p[2].trim();if(!/^\d+$/.test(r))throw new y(`Invalid array length: "${r}". Array length must be a positive integer.`,n.currentLine,void 0,e);const i=parseInt(r,10);if(!Number.isSafeInteger(i)||i<0)throw new y(`Invalid array length: ${r}. Must be a safe integer >= 0.`,n.currentLine,void 0,e);const c=p[3].trim();if(c.includes("{")){const e={isArray:!0,arrayLength:i,columns:[]};s[t]=I(e,c,n)}else{const e=b(c,n.delimiter),r=[];for(const t of e)r.push(T(t));s[t]=r}o++;continue}let f=null,d=null;if(r.startsWith('"')){let e=1,t="";for(;e<r.length;)if("\\"===r[e]&&e+1<r.length&&('"'===r[e+1]||"\\"===r[e+1]))t+=r[e+1],e+=2;else{if('"'===r[e]){for(f=a('"'+t+'"'),e++;e<r.length&&(":"===r[e]||" "===r[e]);)e++;d=r.slice(e).trim();break}t+=r[e],e++}}else{const e=r.match(/^(.*?):\s*(.+)$/);if(e){const t=e[1];f=""===t.trim()?t:t.trim(),d=e[2].trim()}}if(null!==f&&null!==d){if(d.startsWith('"""')){if(!d.endsWith('"""')){const e=[d.slice(3)];for(o++;o<t.length;){const n=t[o];if(n.trim().endsWith('"""')){const t=n.lastIndexOf('"""');if(t>=0){const r=n.match(/^([ \t]*)/)?.[1]?.length||0,i=n.slice(r,t);e.push(i)}o++;break}{const t=n.match(/^([ \t]*)/)?.[1]?.length||0,r=n.slice(t);e.push(r),o++}}s[f]=e.join("\n").replace(/\\"""/g,'"""').replace(/\\\\/g,"\\").replace(/\\r/g,"\r").replace(/\\n/g,"\n").replace(/\\t/g,"\t");continue}s[f]=d.slice(3,-3).replace(/\\"""/g,'"""').replace(/\\\\/g,"\\").replace(/\\r/g,"\r").replace(/\\n/g,"\n").replace(/\\t/g,"\t")}else s[f]=T(d);o++}else{if(n.strict||r.length>0){const i=t.slice(Math.max(0,o-2),Math.min(t.length,o+3)).map((e,t)=>`${o-2+t}: ${e}`).join("\n");if(n.strict)throw new y(`Unparseable line in object block: "${r.substring(0,50)}${r.length>50?"...":""}"\nContext (line ${(n.currentLine||0)+o+1}):\n${i}`,(n.currentLine||0)+o,void 0,e)}o++}}return s}var x=(e=>(e.ROOT="ROOT",e.DOT="DOT",e.DOUBLE_DOT="DOUBLE_DOT",e.LBRACKET="LBRACKET",e.RBRACKET="RBRACKET",e.IDENTIFIER="IDENTIFIER",e.NUMBER="NUMBER",e.STRING="STRING",e.WILDCARD="WILDCARD",e.COLON="COLON",e.COMMA="COMMA",e.QUESTION="QUESTION",e.AT="AT",e.LPAREN="LPAREN",e.RPAREN="RPAREN",e.LBRACE="LBRACE",e.RBRACE="RBRACE",e.EQ="EQ",e.NEQ="NEQ",e.GT="GT",e.LT="LT",e.GTE="GTE",e.LTE="LTE",e.AND="AND",e.OR="OR",e.NOT="NOT",e.CONTAINS="CONTAINS",e.STARTS_WITH="STARTS_WITH",e.ENDS_WITH="ENDS_WITH",e.MATCHES="MATCHES",e.FUZZY_EQ="FUZZY_EQ",e.FUZZY_CONTAINS="FUZZY_CONTAINS",e.FUZZY_STARTS="FUZZY_STARTS",e.FUZZY_ENDS="FUZZY_ENDS",e.FUZZY_MATCH="FUZZY_MATCH",e.SOUNDS_LIKE="SOUNDS_LIKE",e.SIMILAR="SIMILAR",e.BEFORE="BEFORE",e.AFTER="AFTER",e.BETWEEN="BETWEEN",e.DAYS_AGO="DAYS_AGO",e.WEEKS_AGO="WEEKS_AGO",e.MONTHS_AGO="MONTHS_AGO",e.YEARS_AGO="YEARS_AGO",e.SAME_DAY="SAME_DAY",e.SAME_WEEK="SAME_WEEK",e.SAME_MONTH="SAME_MONTH",e.SAME_YEAR="SAME_YEAR",e.TEMPORAL="TEMPORAL",e.EOF="EOF",e))(x||{});class k extends Error{constructor(e,t,r){super(e),n(this,"input"),this.context=t,this.position=r,this.name="ParseError",this.input=t.input}getFormattedMessage(){const{input:e,position:t}=this,n=Math.max(0,t-20),r=Math.min(e.length,t+20),i=e.slice(n,r),s=" ".repeat(t-n)+"^";return`${this.message}\n\n  ${i}\n  ${s}\n  at position ${t}`}}function W(e){const t=[];let n=0;const r={input:e,position:0,tokens:[],currentToken:0};function i(t=0){const r=n+t;return r<e.length?e[r]:null}function s(){return n>=e.length?null:e[n++]}function o(){for(;n<e.length&&/\s/.test(e[n]);)n++}function c(){const t=n;let i="";if(!/[a-zA-Z_$]/.test(e[n]))throw new k(`Expected identifier at position ${n}`,r,n);for(;n<e.length&&/[a-zA-Z0-9_$]/.test(e[n]);)i+=e[n++];return{type:{contains:x.CONTAINS,startsWith:x.STARTS_WITH,endsWith:x.ENDS_WITH,matches:x.MATCHES,fuzzyMatch:x.FUZZY_MATCH,soundsLike:x.SOUNDS_LIKE,similar:x.SIMILAR,before:x.BEFORE,after:x.AFTER,between:x.BETWEEN,daysAgo:x.DAYS_AGO,weeksAgo:x.WEEKS_AGO,monthsAgo:x.MONTHS_AGO,yearsAgo:x.YEARS_AGO,sameDay:x.SAME_DAY,sameWeek:x.SAME_WEEK,sameMonth:x.SAME_MONTH,sameYear:x.SAME_YEAR}[i]||x.IDENTIFIER,value:i,position:t,length:i.length}}function l(){const t=n;let o="";if("-"!==i()&&"+"!==i()||(o+=s()),!/\d/.test(i()||""))throw new k(`Expected digit at position ${n}`,r,n);for(;n<e.length&&/\d/.test(e[n]);)o+=e[n++];if("."===i()&&i(1)&&/\d/.test(i(1)))for(o+=s();n<e.length&&/\d/.test(e[n]);)o+=e[n++];if("e"===i()||"E"===i()){if(o+=s(),"+"!==i()&&"-"!==i()||(o+=s()),!/\d/.test(i()||""))throw new k(`Expected digit in exponent at position ${n}`,r,n);for(;n<e.length&&/\d/.test(e[n]);)o+=e[n++]}const c=parseFloat(o);if(!Number.isFinite(c))throw new k(`Invalid number value: ${o}`,r,t);return{type:x.NUMBER,value:c,position:t,length:o.length}}function a(){const t=n,i=s();let o="",c=!1;for(;n<e.length;){const r=e[n];if(c){switch(r){case"n":o+="\n";break;case"t":o+="\t";break;case"r":o+="\r";break;case"\\":o+="\\";break;case i:o+=i;break;default:o+="\\"+r}c=!1,n++}else if("\\"===r)c=!0,n++;else{if(r===i)return n++,{type:x.STRING,value:o,position:t,length:n-t};o+=r,n++}}throw new k(`Unterminated string literal starting at position ${t}`,r,t)}function u(){const t=n,r=e.slice(n,n+2),i={"==":x.EQ,"!=":x.NEQ,">=":x.GTE,"<=":x.LTE,"&&":x.AND,"||":x.OR,"..":x.DOUBLE_DOT,"~=":x.FUZZY_EQ};return i[r]?(n+=2,{type:i[r],value:r,position:t,length:2}):null}function h(){if("~"!==i())return null;const t=n,r={"~contains":x.FUZZY_CONTAINS,"~startsWith":x.FUZZY_STARTS,"~endsWith":x.FUZZY_ENDS};for(const[i,s]of Object.entries(r))if(e.slice(n,n+i.length)===i){const r=e[n+i.length];if(!r||!/[a-zA-Z0-9_]/.test(r))return n+=i.length,{type:s,value:i,position:t,length:i.length}}return null}function p(){if("@"!==i())return null;const t=n,r=i(1);if(r&&/[a-zA-Z0-9]/.test(r)){s();let r="@";for(;n<e.length;){const t=e[n];if(!/[a-zA-Z0-9\-+:.]/.test(t))break;r+=t,n++}const i=r.substring(1).toLowerCase();return["now","today","yesterday","tomorrow"].some(e=>i.startsWith(e))||/^\d{4}(-\d{2})?(-\d{2})?(t\d{2}:\d{2})?/i.test(i)||/^p\d/i.test(i)?{type:x.TEMPORAL,value:r,position:t,length:r.length}:(n=t,null)}return null}for(;n<e.length&&(o(),!(n>=e.length));){const e=n,o=i();if(!o)break;const f=h();if(f){t.push(f);continue}const d=u();if(d){t.push(d);continue}const m=p();if(m)t.push(m);else switch(o){case"$":i(1)&&/[a-zA-Z_$]/.test(i(1))?t.push(c()):(t.push({type:x.ROOT,value:"$",position:e,length:1}),s());break;case".":t.push({type:x.DOT,value:".",position:e,length:1}),s();break;case"[":t.push({type:x.LBRACKET,value:"[",position:e,length:1}),s();break;case"]":t.push({type:x.RBRACKET,value:"]",position:e,length:1}),s();break;case"*":t.push({type:x.WILDCARD,value:"*",position:e,length:1}),s();break;case":":t.push({type:x.COLON,value:":",position:e,length:1}),s();break;case",":t.push({type:x.COMMA,value:",",position:e,length:1}),s();break;case"?":t.push({type:x.QUESTION,value:"?",position:e,length:1}),s();break;case"@":t.push({type:x.AT,value:"@",position:e,length:1}),s();break;case"(":t.push({type:x.LPAREN,value:"(",position:e,length:1}),s();break;case")":t.push({type:x.RPAREN,value:")",position:e,length:1}),s();break;case">":t.push({type:x.GT,value:">",position:e,length:1}),s();break;case"<":t.push({type:x.LT,value:"<",position:e,length:1}),s();break;case"!":t.push({type:x.NOT,value:"!",position:e,length:1}),s();break;case"{":t.push({type:x.LBRACE,value:"{",position:e,length:1}),s();break;case"}":t.push({type:x.RBRACE,value:"}",position:e,length:1}),s();break;case'"':case"'":t.push(a());break;default:if(/\d/.test(o)||"-"===o&&i(1)&&/\d/.test(i(1)))t.push(l());else{if(!/[a-zA-Z_$]/.test(o))throw new k(`Unexpected character '${o}' at position ${n}`,r,n);t.push(c())}}}return t.push({type:x.EOF,value:null,position:n,length:0}),r.tokens=t,t}function F(e){return{[x.OR]:1,[x.AND]:2,[x.EQ]:3,[x.NEQ]:3,[x.GT]:4,[x.LT]:4,[x.GTE]:4,[x.LTE]:4,[x.CONTAINS]:4,[x.STARTS_WITH]:4,[x.ENDS_WITH]:4,[x.MATCHES]:4,[x.FUZZY_EQ]:4,[x.FUZZY_CONTAINS]:4,[x.FUZZY_STARTS]:4,[x.FUZZY_ENDS]:4,[x.FUZZY_MATCH]:4,[x.SOUNDS_LIKE]:4,[x.SIMILAR]:4,[x.BEFORE]:4,[x.AFTER]:4,[x.BETWEEN]:4,[x.DAYS_AGO]:4,[x.WEEKS_AGO]:4,[x.MONTHS_AGO]:4,[x.YEARS_AGO]:4,[x.SAME_DAY]:4,[x.SAME_WEEK]:4,[x.SAME_MONTH]:4,[x.SAME_YEAR]:4,[x.NOT]:5}[e.type]||0}class D{constructor(e,t){n(this,"currentIndex",0),this.context=e,this.options=t}current(){if(0===this.context.tokens.length)throw new Error("Cannot get current token: token array is empty");return this.context.tokens[this.currentIndex]||this.context.tokens[this.context.tokens.length-1]}peek(e=1){const t=this.currentIndex+e;return t<this.context.tokens.length?this.context.tokens[t]:null}consume(){const e=this.current();return this.currentIndex++,e}match(...e){const t=this.current();return e.includes(t.type)}expect(e,t){const n=this.current();if(n.type!==e)throw new k(t||`Expected ${e} but got ${n.type}`,this.context,n.position);return this.consume()}parse(){const e=[];for(this.match(x.ROOT)&&(this.consume(),e.push({type:"root",symbol:"$"}));!this.match(x.EOF);)if(this.match(x.DOUBLE_DOT))e.push(this.parseRecursive());else if(this.match(x.DOT)){if(this.consume(),this.match(x.IDENTIFIER))e.push(this.parseProperty());else if(this.match(x.WILDCARD))this.consume(),e.push({type:"wildcard"});else if(!this.match(x.EOF))throw new k("Expected property name or wildcard after dot",this.context,this.current().position)}else if(this.match(x.LBRACKET))e.push(this.parseBracketNotation());else if(0===e.length&&this.match(x.IDENTIFIER))e.push(this.parseProperty());else{if(0!==e.length||!this.match(x.WILDCARD)){if(!this.match(x.EOF)){const e=this.current();throw new k(`Unexpected token: ${e.type}`,this.context,e.position)}break}this.consume(),e.push({type:"wildcard"})}return e}parseProperty(){return{type:"property",name:this.expect(x.IDENTIFIER).value}}parseRecursive(){if(this.expect(x.DOUBLE_DOT),this.match(x.IDENTIFIER)){return{type:"recursive",name:this.consume().value}}return this.match(x.WILDCARD)&&this.consume(),{type:"recursive"}}parseBracketNotation(){if(this.expect(x.LBRACKET),this.match(x.WILDCARD))return this.consume(),this.expect(x.RBRACKET),{type:"wildcard"};if(this.match(x.QUESTION))return this.parseFilter();const e=this.current();if(this.match(x.NUMBER)){const e=this.consume().value;return this.match(x.COLON)?this.parseSlice(e):(this.expect(x.RBRACKET),{type:"index",index:e})}if(this.match(x.COLON))return this.parseSlice(void 0);throw new k("Expected number, wildcard, or filter in bracket notation",this.context,e.position)}parseSlice(e){let t,n;return this.expect(x.COLON),this.match(x.NUMBER)&&(t=this.consume().value),this.match(x.COLON)&&(this.consume(),this.match(x.NUMBER)&&(n=this.consume().value)),this.expect(x.RBRACKET),{type:"slice",start:e,end:t,step:n}}parseFilter(){this.expect(x.QUESTION),this.expect(x.LPAREN);const e=this.parseFilterExpression();return this.expect(x.RPAREN),this.expect(x.RBRACKET),{type:"filter",expression:e}}parseFilterExpression(e=0){let t=this.parseFilterPrimary();for(;;){const n=this.current();if(!this.isFilterBinaryOperator(n.type))break;const r=F(n);if(r<e)break;const i=this.consume(),s=this.parseFilterExpression(r+1);t={type:"binary",operator:this.tokenTypeToBinaryOperator(i.type),left:t,right:s}}return t}parseFilterPrimary(){if(this.match(x.LPAREN)){this.consume();const e=this.parseFilterExpression();return this.expect(x.RPAREN),e}if(this.match(x.NOT)){this.consume();return{type:"unary",operator:"!",argument:this.parseFilterPrimary()}}if(this.match(x.AT))return this.parsePropertyExpression();if(this.match(x.NUMBER,x.STRING)){return{type:"literal",value:this.consume().value}}if(this.match(x.IDENTIFIER)){const e=this.peek();if(e&&e.type===x.LPAREN)return this.parseFunctionExpression();const t=this.consume();if("true"===t.value)return{type:"literal",value:!0};if("false"===t.value)return{type:"literal",value:!1};if("null"===t.value)return{type:"literal",value:null};throw new k(`Unexpected identifier in filter: ${t.value}`,this.context,t.position)}throw new k(`Expected filter expression but got ${this.current().type}`,this.context,this.current().position)}parsePropertyExpression(){this.expect(x.AT);const e=[];for(;this.match(x.DOT);){if(this.consume(),!this.match(x.IDENTIFIER))throw new k("Expected property name after dot",this.context,this.current().position);e.push(this.consume().value)}return{type:"property",path:e.join(".")}}parseFunctionExpression(){const e=this.expect(x.IDENTIFIER);this.expect(x.LPAREN);const t=[];if(!this.match(x.RPAREN))for(t.push(this.parseFilterExpression());this.match(x.COMMA);)this.consume(),t.push(this.parseFilterExpression());return this.expect(x.RPAREN),{type:"function",name:e.value,arguments:t}}isFilterBinaryOperator(e){return[x.EQ,x.NEQ,x.GT,x.LT,x.GTE,x.LTE,x.AND,x.OR,x.CONTAINS,x.STARTS_WITH,x.ENDS_WITH,x.MATCHES].includes(e)}tokenTypeToBinaryOperator(e){return{[x.EQ]:"==",[x.NEQ]:"!=",[x.GT]:">",[x.LT]:"<",[x.GTE]:">=",[x.LTE]:"<=",[x.AND]:"&&",[x.OR]:"||",[x.CONTAINS]:"contains",[x.STARTS_WITH]:"startsWith",[x.ENDS_WITH]:"endsWith",[x.MATCHES]:"matches"}[e]||"=="}}function _(e){switch(e.type){case"property":if(!e.name||0===e.name.length)throw new Error("Property node must have a non-empty name");break;case"index":if(!Number.isInteger(e.index))throw new Error("Index must be an integer");break;case"slice":if(void 0!==e.start&&!Number.isInteger(e.start))throw new Error("Slice start must be an integer");if(void 0!==e.end&&!Number.isInteger(e.end))throw new Error("Slice end must be an integer");if(void 0!==e.step&&!Number.isInteger(e.step))throw new Error("Slice step must be an integer");if(0===e.step)throw new Error("Slice step cannot be zero");break;case"filter":L(e.expression);break;case"root":case"wildcard":case"recursive":break;default:throw new Error(`Unknown node type: ${e.type}`)}}function L(e){switch(e.type){case"binary":L(e.left),L(e.right);break;case"unary":L(e.argument);break;case"function":for(const t of e.arguments)L(t);break;case"literal":case"property":break;default:throw new Error(`Unknown filter expression type: ${e.type}`)}}function j(e){const t=[];switch(e.type){case"property":e.name&&0!==e.name.length||t.push("Property node must have a non-empty name"),/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(e.name)||t.push(`Invalid property name: ${e.name}`);break;case"index":Number.isInteger(e.index)||t.push(`Index must be an integer, got: ${e.index}`);break;case"slice":if(void 0===e.start||Number.isInteger(e.start)||t.push(`Slice start must be an integer, got: ${e.start}`),void 0===e.end||Number.isInteger(e.end)||t.push(`Slice end must be an integer, got: ${e.end}`),void 0!==e.step&&(Number.isInteger(e.step)||t.push(`Slice step must be an integer, got: ${e.step}`),0===e.step&&t.push("Slice step cannot be zero")),void 0!==e.start&&void 0!==e.end&&e.start>e.end){const n=void 0!==e.step&&e.step<0,r=e.start<0||e.end<0;n||r||t.push(`Slice start (${e.start}) is greater than end (${e.end})`)}break;case"filter":const n=C(e.expression);t.push(...n);break;case"root":"$"!==e.symbol&&t.push(`Root node must have symbol '$', got: ${e.symbol}`);break;case"wildcard":case"recursive":break;default:t.push(`Unknown node type: ${e.type}`)}return t}function M(e,t,n){const r=[];return"root"===e.type&&0!==n&&r.push("Root node ($) must be the first node in the path"),t&&"root"===t.type&&"root"===e.type&&r.push("Cannot have multiple root nodes"),r}function C(e){const t=[];switch(e.type){case"binary":["==","!=",">","<",">=","<=","&&","||","contains","startsWith","endsWith","matches","in","typeof","instanceof"].includes(e.operator)||t.push(`Invalid binary operator: ${e.operator}`),t.push(...C(e.left)),t.push(...C(e.right));break;case"unary":["!","exists","empty"].includes(e.operator)||t.push(`Invalid unary operator: ${e.operator}`),t.push(...C(e.argument));break;case"function":e.name&&0!==e.name.length||t.push("Function expression must have a name");for(const n of e.arguments)t.push(...C(n));break;case"property":e.path&&0!==e.path.length||t.push("Property expression must have a non-empty path");break;case"literal":break;default:t.push(`Unknown filter expression type: ${e.type}`)}return t}function Z(e){switch(e.type){case"binary":return`${Z(e.left)} ${e.operator} ${Z(e.right)}`;case"unary":return`${e.operator}${Z(e.argument)}`;case"literal":return"string"==typeof e.value?`"${e.value}"`:String(e.value);case"property":return"@."+e.path;case"function":const t=e.arguments.map(e=>Z(e)).join(", ");return`${e.name}(${t})`;default:return""}}return e.ParseError=k,e.TokenType=x,e.analyzeAST=function(e){const t={};let n=!1,r=!1,i=!1,s=!0;for(const c of e)t[c.type]=(t[c.type]||0)+1,"wildcard"===c.type&&(n=!0,s=!1),"recursive"===c.type&&(r=!0,s=!1),"filter"===c.type&&(i=!0,s=!1),"slice"===c.type&&(s=!1);let o=1;return o+=.5*e.length,n&&(o+=2),r&&(o+=3),i&&(o+=2),o=Math.min(10,Math.round(o)),{depth:e.length,hasWildcard:n,hasRecursive:r,hasFilter:i,isDeterministic:s,complexity:o,nodeTypes:t}},e.astToString=function(e){if(0===e.length)return"";let t="";for(let n=0;n<e.length;n++){const r=e[n],i=n>0?e[n-1]:null;switch(r.type){case"root":t+="$";break;case"property":(i&&"root"!==i.type||i)&&(t+="."),t+=r.name;break;case"index":t+=`[${r.index}]`;break;case"wildcard":i&&"property"===i.type?t+="[*]":t+="*";break;case"recursive":t+="..",r.name&&(t+=r.name);break;case"slice":t+="[",void 0!==r.start&&(t+=r.start),t+=":",void 0!==r.end&&(t+=r.end),void 0!==r.step&&(t+=":"+r.step),t+="]";break;case"filter":t+="[?("+Z(r.expression)+")]"}}return t},e.coerceValue=i,e.decodeTONL=function(e,t={}){const n=t.strict??!1,r=e.split("\n").map(e=>e.replace(/\r$/,"")).filter(e=>e.length>0);if(0===r.length)return{};const i={header:{},strict:n,delimiter:t.delimiter||",",allLines:r,currentLine:0};let s=0;for(let l=0;l<r.length;l++){const e=r[l];if(e.startsWith("@")){const t=e.indexOf(":");if(e.indexOf(" "),e.indexOf("\t"),t>0){const n=e.substring(1,t).trim();if(["version","delimiter","import","schema","type","description"].includes(n)){s=l+1;continue}break}break}if(!e.startsWith("#"))break;{const t=A(e);if(t)if("version"===t.key)i.header.version=t.value;else if("delimiter"===t.key)if("\\t"===t.value)i.header.delimiter="\t";else{if(","!==t.value&&"|"!==t.value&&";"!==t.value)throw new y(`Invalid delimiter: ${t.value}`,l,void 0,e,"Valid delimiters are: , | \\t ;");i.header.delimiter=t.value}s=l+1}}t.delimiter||(i.header.delimiter?i.delimiter=i.header.delimiter:i.delimiter=v(e));const o=r.slice(s).join("\n");if(!o)return{};const c=function(e,t){const n=e.split("\n"),r={};let i=0;for(;i<n.length;){const e=n[i],o=e.trim();if(!o||o.startsWith("#")){i++;continue}if(o.startsWith("@")){const e=o.indexOf(":");if(e>0){const t=o.substring(1,e).trim();if(["version","delimiter","import","schema","type","description"].includes(t)){i++;continue}}}const c=o.match(/^(.+)\{([^}]*)\}:\s+(.+)$/);if(c){const e=c[1].trim(),n=c[2].trim(),s=c[3].trim(),o=[];if(n){const e=n.split(",");for(const t of e){const e=t.trim();if(!e)continue;let n,r;if(e.startsWith('"')){const t=e.indexOf('"',1);if(t>0){n=e.slice(1,t).replace(/""/g,'"');const i=e.slice(t+1),s=i.indexOf(":");s>=0&&(r=i.slice(s+1).trim())}else n=e}else{const t=e.indexOf(":");t>0?(n=e.slice(0,t).trim(),r=e.slice(t+1).trim()):n=e}r?o.push({name:n,type:r}):o.push({name:n})}}const l={key:e,isArray:!1,columns:o},a=I(l,s,t);r[l.key]=a,i++;continue}const l=$(o);if(l){const e=N(l,n,i,t);r[l.key]=e,i=S(n,i)}else{let c=null;if(o.length<1e3)try{c=o.match(/^(.{1,200})\[([^\]]{1,20})\]:\s*(.{0,1000})$/)}catch(s){}if(c){const n=c[1].trim(),s=c[2].trim();if(s.length>16)throw new y(`Invalid array length: "${s.substring(0,20)}...". Array length too long (max 16 digits).`,t.currentLine,void 0,e);if(!/^\d+$/.test(s))throw new y(`Invalid array length: "${s}". Array length must be a positive integer.`,t.currentLine,void 0,e);const o=parseInt(s,10);if(!Number.isSafeInteger(o)||o<0)throw new y(`Invalid array length: ${s}. Must be a safe integer >= 0.`,t.currentLine,void 0,e);const l=b(c[3].trim(),t.delimiter),a=[];for(const e of l)a.push(T(e));r[n]=a,i++;continue}const l=o.match(/^([^:]+):\s*(.*)$/);if(l){const e=l[1].trim();let t=l[2].trim();if(t.startsWith('"""')&&-1===t.slice(3).indexOf('"""')){let e=t;for(i++;i<n.length;){const t=n[i];if(e+="\n"+t,t.includes('"""'))break;i++}t=e.trim()}r[e]=T(t)}i++}}return r}(o,i);return c&&"object"==typeof c&&1===Object.keys(c).length&&"root"in c?c.root:c},e.detectDelimiter=v,e.encodeSmart=function(e,t){const n=JSON.stringify(e);let r=0,i=0,s=0,o=0;for(let a=0;a<n.length;a++)switch(n[a]){case",":r++;break;case"|":i++;break;case"\t":s++;break;case";":o++}let c=",",l=r;return i<l&&(c="|",l=i),s<l&&(c="\t",l=s),o<l&&(c=";",l=o),p(e,{delimiter:c,includeTypes:!1,version:"1.0",indent:2,singleLinePrimitiveLists:!0,...t})},e.encodeTONL=p,e.inferPrimitiveType=r,e.isUniformObjectArray=s,e.optimizeAST=function(e){if(0===e.length)return e;const t=[];for(let n=0;n<e.length;n++){const r=e[n];t[t.length-1],0===n&&"root"===r.type&&e.length,t.push(r)}return t},e.parseHeaderLine=A,e.parseObjectHeader=$,e.parsePath=function(e,t={}){const{validate:n=!0,allowPartial:r=!1,maxRecursionDepth:i=100}=t;try{const t=W(e),s=new D({input:e,position:0,tokens:t,currentToken:0},{allowPartial:r,maxRecursionDepth:i}).parse();return n&&s.length>0&&function(e){const t=e.filter(e=>"recursive"===e.type).length;if(t>10)throw new Error("Too many recursive descent operators in path");for(const n of e)_(n)}(s),{ast:s,success:!0,input:e}}catch(s){if(s instanceof k)return{ast:[],success:!1,error:s,input:e};throw s}},e.parseTONLLine=b,e.tokenize=W,e.validate=function(e){const t=[],n=[];if(0===e.length)return n.push("Empty path"),{valid:!0,errors:t,warnings:n};for(let i=0;i<e.length;i++){const n=e[i],r=i>0?e[i-1]:null,s=j(n);t.push(...s);const o=M(n,r,i);t.push(...o)}const r=function(e){const t=[],n=e.filter(e=>"recursive"===e.type).length;n>5&&t.push(`Path contains ${n} recursive descents, which may be slow`);for(let r=0;r<e.length-1;r++)"wildcard"===e[r].type&&"filter"===e[r+1].type&&t.push("Wildcard followed by filter at index "+r+" - consider filter optimization");for(let r=0;r<e.length-1;r++)"wildcard"===e[r].type&&"wildcard"===e[r+1].type&&t.push("Consecutive wildcards at index "+r+" may return unexpected results");return t}(e);return n.push(...r),{valid:0===t.length,errors:t,warnings:n}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),e}({});
